# 简单函数

## C标准库和glibc

C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件
中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准
库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单片机的C语言开发工具中只有C编译器而没有
完整的C标准库。

在Linux平台上最广泛使用的C函数库是** glibc **，其中包括C标准库的实现，也包括本书第三部分介绍的所有系统函数。
几乎所有C程序都要调用 ** glibc ** 的库函数，所以 ** glibc ** 是Linux平台C程序运行的基础。 ** glibc ** 提供一组
头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在 ** libc.so ** 库文件中，几乎所有C程序的运行都依赖
于 ** glibc **，有些做数学计算的C程序依赖于 ** libm.so **，以后我们还会看到多线程的C程序依赖于 ** libpthread.so **。
以后我说 ** libc ** 时专指 ** libc.so **，这个库文件，而说 ** glibc ** 时指的是 ** glibc ** 提供的所有库文件。


## C语言的全局变量的初始化只允许使用常量表达式

在C语言中，局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant Expression）初始化。例如：全局变量 ** pi ** 这样初始化是合法的：

```c
double pi = 3.14 + 0.0016
```

但是这样初始化是不合法的：

```c
double pi = acos(-1.0);
```

然而局部变量这样初始化却是可以的。程序开始时要用适当的值来初始化全局变量，所以初始值必须保存在编译
生成的可执行文件中，因此初始值在编译时就要计算出来，然而上面第二种Initializer的值在程序运行时调用 ** acos ** 函数才能得到，
所以不能用来初始化全局变量。请注意区分编译时和运行时这两个概念。为了简化编译器的实现，C语言从语法上规定
全局变量只能用常量表达式来初始化，因此下面这种全局变量初始化是不合法的：

```c
int minute = 360;
int hour = minute / 60;
```

虽然在编译时计算出hour的初始值是可能的，但是minute / 60 不是常量表达式，不符合语法规定，所以编译器不必想办法去算这个初始值。

如果全局变量在定义时不初始化则初始值为0，如果局部变量在定义时不初始化则初始值是不确定的。所以，局部变量在使用之前一定要先赋值，
如果基于一个不确定的值做后续计算肯定会引入BUG。

